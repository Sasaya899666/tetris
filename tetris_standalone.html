<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ä¿„ç¾…æ–¯æ–¹å¡Š - ç¨ç«‹ç‰ˆ</title>
  <style>
    /* å…¨å±€æ¨£å¼ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
      overflow-x: hidden;
    }

    /* éŠæˆ²å®¹å™¨ */
    .game-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    /* éŠæˆ²æ¨™é¡Œ */
    .game-header {
      text-align: center;
      margin-bottom: 30px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .game-header h1 {
      color: white;
      font-size: 2.5rem;
      margin-bottom: 15px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    /* ä¸»éŠæˆ²å€åŸŸ */
    .main-game-area {
      display: flex;
      gap: 30px;
      justify-content: center;
      align-items: flex-start;
      flex-wrap: wrap;
    }

    /* éŠæˆ²ç•«å¸ƒ */
    .game-board {
      position: relative;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    #tetris {
      border: 3px solid #4a90e2;
      border-radius: 10px;
      background: #000;
      box-shadow: inset 0 0 20px rgba(74, 144, 226, 0.3);
    }

    /* éŠæˆ²è¦†è“‹å±¤ */
    .game-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      border-radius: 10px;
    }

    .overlay-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      width: 90%;
    }

    .overlay-content h2 {
      color: #e74c3c;
      margin-bottom: 15px;
      font-size: 1.8rem;
    }

    .overlay-content p {
      font-size: 1.2rem;
      margin-bottom: 20px;
      color: #333;
    }

    /* éŠæˆ²è³‡è¨Šé¢æ¿ */
    .game-info {
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: 300px;
    }

    .info-section {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .info-section h3 {
      color: white;
      margin-bottom: 15px;
      font-size: 1.2rem;
      text-align: center;
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    .info-item:last-child {
      border-bottom: none;
    }

    .label {
      color: #ddd;
      font-weight: 500;
    }

    .value {
      color: #4a90e2;
      font-weight: bold;
      font-size: 1.1rem;
    }

    #preview {
      border: 2px solid #4a90e2;
      border-radius: 8px;
      background: #000;
      display: block;
      margin: 0 auto;
    }

    /* æŒ‰éˆ•æ¨£å¼ */
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
      text-align: center;
      min-width: 100px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .btn-primary {
      background: linear-gradient(45deg, #4a90e2, #357abd);
      color: white;
    }

    .btn-primary:hover {
      background: linear-gradient(45deg, #357abd, #4a90e2);
    }

    .btn-success {
      background: linear-gradient(45deg, #27ae60, #2ecc71);
      color: white;
    }

    .btn-success:hover {
      background: linear-gradient(45deg, #2ecc71, #27ae60);
    }

    .btn-warning {
      background: linear-gradient(45deg, #f39c12, #e67e22);
      color: white;
    }

    .btn-warning:hover {
      background: linear-gradient(45deg, #e67e22, #f39c12);
    }

    .btn-danger {
      background: linear-gradient(45deg, #e74c3c, #c0392b);
      color: white;
    }

    .btn-danger:hover {
      background: linear-gradient(45deg, #c0392b, #e74c3c);
    }

    .control-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .controls-info {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-item {
      color: #ddd;
      font-size: 14px;
      padding: 5px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .control-item:last-child {
      border-bottom: none;
    }

    /* æœ¬åœ°æ’è¡Œæ¦œ */
    .local-leaderboard {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      margin-top: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .leaderboard-title {
      color: white;
      text-align: center;
      margin-bottom: 15px;
      font-size: 1.2rem;
    }

    .leaderboard-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      margin-bottom: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: white;
    }

    .leaderboard-item:first-child {
      background: linear-gradient(45deg, #ffd700, #ffed4e);
      color: #333;
    }

    .leaderboard-item:nth-child(2) {
      background: linear-gradient(45deg, #c0c0c0, #e0e0e0);
      color: #333;
    }

    .leaderboard-item:nth-child(3) {
      background: linear-gradient(45deg, #cd7f32, #daa520);
      color: white;
    }

    /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
    @media (max-width: 768px) {
      .main-game-area {
        flex-direction: column;
        align-items: center;
      }
      
      .game-info {
        width: 100%;
        max-width: 400px;
      }
      
      .game-header h1 {
        font-size: 2rem;
      }
    }

    @media (max-width: 480px) {
      .game-container {
        padding: 10px;
      }
      
      .game-header h1 {
        font-size: 1.5rem;
      }
      
      .info-section {
        padding: 15px;
      }
      
      .btn {
        padding: 10px 20px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <!-- ä¸»æ¨™é¡Œ -->
    <header class="game-header">
      <h1>ğŸ® ä¿„ç¾…æ–¯æ–¹å¡Š - ç¨ç«‹ç‰ˆ</h1>
      <p style="color: white; margin: 0;">ç„¡éœ€ç¶²è·¯é€£æ¥ï¼Œé›¢ç·šéŠæˆ²</p>
    </header>

    <!-- ä¸»éŠæˆ²å€åŸŸ -->
    <div class="main-game-area">
      <!-- éŠæˆ²ç•«å¸ƒ -->
      <div class="game-board">
        <canvas id="tetris" width="300" height="600"></canvas>
        <div class="game-overlay" id="gameOverlay">
          <div class="overlay-content">
            <h2 id="overlayTitle">éŠæˆ²çµæŸ</h2>
            <p id="overlayMessage">æ‚¨çš„åˆ†æ•¸: <span id="finalScore">0</span></p>
            <div id="nameInputSection" style="display: none;">
              <input type="text" id="playerName" placeholder="è«‹è¼¸å…¥æ‚¨çš„å§“å (2-20å­—å…ƒ)" maxlength="20" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; margin-bottom: 15px;">
              <button id="submitScore" class="btn btn-primary">æäº¤åˆ†æ•¸</button>
            </div>
            <button id="restartGame" class="btn btn-primary">é‡æ–°é–‹å§‹</button>
          </div>
        </div>
      </div>

      <!-- éŠæˆ²è³‡è¨Šé¢æ¿ -->
      <div class="game-info">
        <div class="info-section">
          <h3>ğŸ¯ éŠæˆ²è³‡è¨Š</h3>
          <div class="info-item">
            <span class="label">åˆ†æ•¸:</span>
            <span id="score" class="value">0</span>
          </div>
          <div class="info-item">
            <span class="label">ç­‰ç´š:</span>
            <span id="level" class="value">1</span>
          </div>
          <div class="info-item">
            <span class="label">æ¶ˆé™¤è¡Œæ•¸:</span>
            <span id="lines" class="value">0</span>
          </div>
          <div class="info-item">
            <span class="label">æœ€é«˜åˆ†:</span>
            <span id="highscore" class="value">0</span>
          </div>
        </div>

        <div class="info-section">
          <h3>ğŸ”® ä¸‹ä¸€å€‹æ–¹å¡Š</h3>
          <canvas id="preview" width="120" height="120"></canvas>
        </div>

        <div class="info-section">
          <h3>ğŸ® éŠæˆ²æ§åˆ¶</h3>
          <div class="control-buttons">
            <button id="startBtn" class="btn btn-success">é–‹å§‹éŠæˆ²</button>
            <button id="pauseBtn" class="btn btn-warning">æš«åœ</button>
            <button id="resetBtn" class="btn btn-danger">é‡æ–°é–‹å§‹</button>
          </div>
        </div>

        <div class="info-section">
          <h3>âŒ¨ï¸ æ“ä½œèªªæ˜</h3>
          <div class="controls-info">
            <div class="control-item">â† â†’ ç§»å‹•</div>
            <div class="control-item">â†‘ æ—‹è½‰</div>
            <div class="control-item">â†“ å¿«é€Ÿä¸‹è½</div>
            <div class="control-item">ç©ºç™½éµ ç«‹å³è½ä¸‹</div>
            <div class="control-item">P æš«åœ</div>
          </div>
        </div>
      </div>
    </div>

    <!-- æœ¬åœ°æ’è¡Œæ¦œ -->
    <div class="local-leaderboard">
      <h3 class="leaderboard-title">ğŸ† æœ¬åœ°æ’è¡Œæ¦œ</h3>
      <div id="localLeaderboard">
        <!-- æ’è¡Œæ¦œå…§å®¹å°‡ç”±JavaScriptå‹•æ…‹ç”Ÿæˆ -->
      </div>
    </div>
  </div>

  <script>
    // ä¿„ç¾…æ–¯æ–¹å¡ŠéŠæˆ²æ ¸å¿ƒé‚è¼¯
    class TetrisGame {
      constructor() {
        console.log('é–‹å§‹åˆå§‹åŒ–éŠæˆ²...');
        
        this.canvas = document.getElementById('tetris');
        if (!this.canvas) {
          throw new Error('æ‰¾ä¸åˆ°éŠæˆ²ç•«å¸ƒå…ƒç´ ');
        }
        this.context = this.canvas.getContext('2d');
        
        this.previewCanvas = document.getElementById('preview');
        if (!this.previewCanvas) {
          throw new Error('æ‰¾ä¸åˆ°é è¦½ç•«å¸ƒå…ƒç´ ');
        }
        this.previewCtx = this.previewCanvas.getContext('2d');
        
        console.log('ç•«å¸ƒå…ƒç´ æ‰¾åˆ°ï¼Œè¨­ç½®ç¸®æ”¾...');
        
        // è¨­ç½®ç•«å¸ƒç¸®æ”¾
        this.context.scale(15, 15);
        this.previewCtx.scale(20, 20);
        
        // éŠæˆ²ç‹€æ…‹
        this.arena = this.createMatrix(20, 10);
        this.player = {
          pos: {x: 0, y: 0},
          matrix: null,
          next: null
        };
        
        // éŠæˆ²è®Šæ•¸
        this.dropCounter = 0;
        this.dropInterval = 1000;
        this.lastTime = 0;
        this.gameOver = false;
        this.paused = false;
        this.score = 0;
        this.level = 1;
        this.lines = 0;
        this.highscore = localStorage.getItem('tetrisHighscore') || 0;
        this.gameStartTime = 0;
        this.gameDuration = 0;
        
        // æ–¹å¡Šé¡è‰²
        this.colors = [
          null,
          '#ff0d72', '#0dc2ff', '#0dff72', '#f538ff', '#ff8e0d', '#ffe138', '#3877ff'
        ];
        
        // æ–¹å¡Šé¡å‹
        this.pieces = 'TJLOSZI';
        
        // æœ¬åœ°æ’è¡Œæ¦œ
        this.localLeaderboard = JSON.parse(localStorage.getItem('tetrisLeaderboard') || '[]');
        
        // åˆå§‹åŒ–éŠæˆ²
        this.init();
      }
      
      init() {
        console.log('åˆå§‹åŒ–éŠæˆ²ç‹€æ…‹...');
        this.updateScore();
        this.playerReset();
        this.drawPreview();
        this.updateLocalLeaderboard();
        console.log('éŠæˆ²åˆå§‹åŒ–å®Œæˆ');
      }
      
      createMatrix(w, h) {
        const matrix = [];
        while (h--) {
          matrix.push(new Array(w).fill(0));
        }
        return matrix;
      }
      
      createPiece(type) {
        const pieces = {
          'T': [[0,1,0],[1,1,1],[0,0,0]],
          'O': [[2,2],[2,2]],
          'L': [[0,0,3],[3,3,3],[0,0,0]],
          'J': [[4,0,0],[4,4,4],[0,0,0]],
          'I': [[0,0,0,0],[5,5,5,5],[0,0,0,0],[0,0,0,0]],
          'S': [[0,6,6],[6,6,0],[0,0,0]],
          'Z': [[7,7,0],[0,7,7],[0,0,0]]
        };
        return pieces[type];
      }
      
      drawMatrix(matrix, offset, ctx) {
        matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              ctx.fillStyle = this.colors[value];
              ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
              
              // æ·»åŠ é‚Šæ¡†æ•ˆæœ
              ctx.strokeStyle = '#000';
              ctx.lineWidth = 0.05;
              ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
            }
          });
        });
      }
      
      draw() {
        try {
          this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
          
          // ç¹ªè£½ç¶²æ ¼èƒŒæ™¯
          this.drawGrid();
          
          // ç¹ªè£½éŠæˆ²å€åŸŸ
          this.drawMatrix(this.arena, {x: 0, y: 0}, this.context);
          this.drawMatrix(this.player.matrix, this.player.pos, this.context);
        } catch (error) {
          console.error('ç¹ªè£½éŠæˆ²æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
        }
      }
      
      drawGrid() {
        this.context.strokeStyle = '#333';
        this.context.lineWidth = 0.1;
        
        // ç¹ªè£½å‚ç›´ç·š
        for (let x = 0; x <= 10; x++) {
          this.context.beginPath();
          this.context.moveTo(x, 0);
          this.context.lineTo(x, 20);
          this.context.stroke();
        }
        
        // ç¹ªè£½æ°´å¹³ç·š
        for (let y = 0; y <= 20; y++) {
          this.context.beginPath();
          this.context.moveTo(0, y);
          this.context.lineTo(10, y);
          this.context.stroke();
        }
      }
      
      drawPreview() {
        this.previewCtx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
        if (this.player.next) {
          this.drawMatrix(this.player.next, {x: 1, y: 1}, this.previewCtx);
        }
      }
      
      merge(arena, player) {
        player.matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              arena[y + player.pos.y][x + player.pos.x] = value;
            }
          });
        });
      }
      
      collide(arena, player) {
        const m = player.matrix;
        const o = player.pos;
        for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 && 
                (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
              return true;
            }
          }
        }
        return false;
      }
      
      playerDrop() {
        this.player.pos.y++;
        if (this.collide(this.arena, this.player)) {
          this.player.pos.y--;
          this.merge(this.arena, this.player);
          this.playerReset();
          this.arenaSweep();
          this.updateScore();
        }
        this.dropCounter = 0;
      }
      
      playerMove(dir) {
        this.player.pos.x += dir;
        if (this.collide(this.arena, this.player)) {
          this.player.pos.x -= dir;
        }
      }
      
      playerReset() {
        console.log('é‡ç½®ç©å®¶ç‹€æ…‹...');
        this.player.matrix = this.player.next || this.createPiece(this.pieces[Math.floor(Math.random() * this.pieces.length)]);
        this.player.next = this.createPiece(this.pieces[Math.floor(Math.random() * this.pieces.length)]);
        this.player.pos.y = 0;
        this.player.pos.x = (this.arena[0].length / 2 | 0) - (this.player.matrix[0].length / 2 | 0);
        
        console.log('ç©å®¶ä½ç½®:', this.player.pos);
        console.log('ç©å®¶æ–¹å¡Š:', this.player.matrix);
        
        if (this.collide(this.arena, this.player)) {
          console.log('éŠæˆ²çµæŸï¼');
          this.gameOver = true;
          this.endGame();
        }
        this.drawPreview();
      }
      
      playerRotate() {
        const m = this.player.matrix;
        for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < y; ++x) {
            [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
          }
        }
        m.forEach(row => row.reverse());
        
        if (this.collide(this.arena, this.player)) {
          m.forEach(row => row.reverse());
          for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < y; ++x) {
              [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
            }
          }
        }
      }
      
      arenaSweep() {
        let rowCount = 1;
        let linesCleared = 0;
        
        outer: for (let y = this.arena.length - 1; y >= 0; --y) {
          for (let x = 0; x < this.arena[y].length; ++x) {
            if (this.arena[y][x] === 0) continue outer;
          }
          
          const row = this.arena.splice(y, 1)[0].fill(0);
          this.arena.unshift(row);
          ++y;
          linesCleared++;
          
          // åˆ†æ•¸è¨ˆç®—ï¼šåŸºç¤åˆ†æ•¸ * ç­‰ç´š * é€£é–å€æ•¸
          this.score += rowCount * 100 * this.level;
          rowCount *= 2;
        }
        
        this.lines += linesCleared;
        
        // ç­‰ç´šæå‡
        if (this.lines >= this.level * 10) {
          this.level++;
          this.dropInterval = Math.max(100, 1000 - (this.level - 1) * 100);
        }
      }
      
      update(time = 0) {
        if (this.paused || this.gameOver) {
          console.log('éŠæˆ²æš«åœæˆ–çµæŸï¼Œåœæ­¢æ›´æ–°');
          return;
        }
        
        const deltaTime = time - this.lastTime;
        this.lastTime = time;
        
        this.dropCounter += deltaTime;
        if (this.dropCounter > this.dropInterval) {
          this.playerDrop();
        }
        
        this.draw();
        requestAnimationFrame((time) => this.update(time));
      }
      
      updateScore() {
        document.getElementById('score').innerText = this.score.toLocaleString();
        document.getElementById('level').innerText = this.level;
        document.getElementById('lines').innerText = this.lines;
        
        if (this.score > this.highscore) {
          this.highscore = this.score;
          localStorage.setItem('tetrisHighscore', this.highscore);
          document.getElementById('highscore').innerText = this.highscore.toLocaleString();
        }
      }
      
      startGame() {
        console.log('é–‹å§‹éŠæˆ²...');
        if (this.gameOver) {
          console.log('éŠæˆ²çµæŸç‹€æ…‹ï¼Œé‡ç½®éŠæˆ²');
          this.resetGame();
        }
        this.paused = false;
        this.gameStartTime = Date.now();
        this.lastTime = 0; // é‡ç½®æ™‚é–“
        console.log('é–‹å§‹éŠæˆ²å¾ªç’°');
        this.update();
      }
      
      pauseGame() {
        this.paused = !this.paused;
        if (!this.paused) {
          this.update();
        }
      }
      
      resetGame() {
        this.arena = this.createMatrix(20, 10);
        this.score = 0;
        this.level = 1;
        this.lines = 0;
        this.dropInterval = 1000;
        this.gameOver = false;
        this.paused = false;
        this.gameStartTime = 0;
        this.gameDuration = 0;
        
        this.playerReset();
        this.updateScore();
        this.update();
      }
      
      endGame() {
        this.gameDuration = Math.floor((Date.now() - this.gameStartTime) / 1000);
        
        // æª¢æŸ¥æ˜¯å¦ç‚ºå‰10å
        this.checkLocalLeaderboard();
        
        // é¡¯ç¤ºéŠæˆ²çµæŸç•«é¢
        this.showGameOver();
      }
      
      showGameOver() {
        const overlay = document.getElementById('gameOverlay');
        const title = document.getElementById('overlayTitle');
        const message = document.getElementById('overlayMessage');
        const finalScore = document.getElementById('finalScore');
        const nameInputSection = document.getElementById('nameInputSection');
        
        title.innerText = 'éŠæˆ²çµæŸï¼';
        finalScore.innerText = this.score.toLocaleString();
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦è¼¸å…¥å§“å
        if (this.score > 0) {
          nameInputSection.style.display = 'block';
          message.innerText = `æ‚¨çš„åˆ†æ•¸: ${this.score.toLocaleString()}`;
        } else {
          nameInputSection.style.display = 'none';
          message.innerText = 'éŠæˆ²çµæŸï¼';
        }
        
        overlay.style.display = 'flex';
      }
      
      checkLocalLeaderboard() {
        // æª¢æŸ¥æ˜¯å¦ç‚ºå‰10å
        const isTop10 = this.localLeaderboard.length < 10 || this.score > this.localLeaderboard[this.localLeaderboard.length - 1].score;
        
        if (isTop10) {
          // é¡¯ç¤ºå§“åè¼¸å…¥
          document.getElementById('nameInputSection').style.display = 'block';
        }
      }
      
      submitLocalScore(playerName) {
        // æ·»åŠ åˆ°æœ¬åœ°æ’è¡Œæ¦œ
        this.localLeaderboard.push({
          name: playerName,
          score: this.score,
          level: this.level,
          lines_cleared: this.lines,
          date: new Date().toLocaleDateString()
        });
        
        // æ’åºä¸¦åªä¿ç•™å‰10å
        this.localLeaderboard.sort((a, b) => b.score - a.score);
        this.localLeaderboard = this.localLeaderboard.slice(0, 10);
        
        // ä¿å­˜åˆ°æœ¬åœ°å­˜å„²
        localStorage.setItem('tetrisLeaderboard', JSON.stringify(this.localLeaderboard));
        
        // æ›´æ–°é¡¯ç¤º
        this.updateLocalLeaderboard();
        
        alert(`æ­å–œï¼æ‚¨çš„åˆ†æ•¸å·²è¨˜éŒ„åˆ°æœ¬åœ°æ’è¡Œæ¦œï¼`);
      }
      
      updateLocalLeaderboard() {
        const leaderboardDiv = document.getElementById('localLeaderboard');
        leaderboardDiv.innerHTML = '';
        
        if (this.localLeaderboard.length === 0) {
          leaderboardDiv.innerHTML = '<div style="color: white; text-align: center;">æš«ç„¡è¨˜éŒ„</div>';
          return;
        }
        
        this.localLeaderboard.forEach((player, index) => {
          const item = document.createElement('div');
          item.className = 'leaderboard-item';
          item.innerHTML = `
            <div>
              <strong>${index + 1}. ${player.name}</strong>
              <div style="font-size: 0.9em; opacity: 0.8;">ç­‰ç´š: ${player.level} | è¡Œæ•¸: ${player.lines_cleared}</div>
            </div>
            <div style="text-align: right;">
              <div style="font-weight: bold;">${player.score.toLocaleString()}</div>
              <div style="font-size: 0.8em; opacity: 0.8;">${player.date}</div>
            </div>
          `;
          leaderboardDiv.appendChild(item);
        });
      }
      
      // éµç›¤æ§åˆ¶
      handleKeydown(event) {
        if (this.gameOver) return;
        
        switch(event.key) {
          case 'ArrowLeft':
            this.playerMove(-1);
            break;
          case 'ArrowRight':
            this.playerMove(1);
            break;
          case 'ArrowDown':
            this.playerDrop();
            break;
          case 'ArrowUp':
            this.playerRotate();
            break;
          case ' ':
            // ç¡¬é™
            while (!this.collide(this.arena, this.player)) {
              this.player.pos.y++;
            }
            this.player.pos.y--;
            this.merge(this.arena, this.player);
            this.playerReset();
            this.arenaSweep();
            this.updateScore();
            break;
          case 'p':
          case 'P':
            this.pauseGame();
            break;
        }
      }
    }

    // åˆå§‹åŒ–éŠæˆ²
    let game;

    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMè¼‰å…¥å®Œæˆï¼Œåˆå§‹åŒ–éŠæˆ²...');
      
      try {
        game = new TetrisGame();
        console.log('éŠæˆ²åˆå§‹åŒ–æˆåŠŸ');
        
        // å°å‡ºéŠæˆ²å¯¦ä¾‹ä¾›å…¶ä»–æ¨¡çµ„ä½¿ç”¨
        window.game = game;
        
        // éµç›¤äº‹ä»¶ç›£è½
        document.addEventListener('keydown', (event) => {
          game.handleKeydown(event);
        });
        
        // æŒ‰éˆ•äº‹ä»¶
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        if (startBtn) {
          startBtn.addEventListener('click', () => {
            console.log('é–‹å§‹éŠæˆ²æŒ‰éˆ•è¢«é»æ“Š');
            game.startGame();
          });
        } else {
          console.error('æ‰¾ä¸åˆ°é–‹å§‹éŠæˆ²æŒ‰éˆ•');
        }
        
        if (pauseBtn) {
          pauseBtn.addEventListener('click', () => {
            console.log('æš«åœæŒ‰éˆ•è¢«é»æ“Š');
            game.pauseGame();
          });
        } else {
          console.error('æ‰¾ä¸åˆ°æš«åœæŒ‰éˆ•');
        }
        
        if (resetBtn) {
          resetBtn.addEventListener('click', () => {
            console.log('é‡æ–°é–‹å§‹æŒ‰éˆ•è¢«é»æ“Š');
            game.resetGame();
          });
        } else {
          console.error('æ‰¾ä¸åˆ°é‡æ–°é–‹å§‹æŒ‰éˆ•');
        }
        
        // æäº¤åˆ†æ•¸
        const submitScoreBtn = document.getElementById('submitScore');
        if (submitScoreBtn) {
          submitScoreBtn.addEventListener('click', () => {
            const playerName = document.getElementById('playerName').value.trim();
            if (playerName.length >= 2 && playerName.length <= 20) {
              game.submitLocalScore(playerName);
              document.getElementById('gameOverlay').style.display = 'none';
            } else {
              alert('è«‹è¼¸å…¥2-20å­—å…ƒçš„å§“å');
            }
          });
        }
        
        // é‡æ–°é–‹å§‹éŠæˆ²
        const restartGameBtn = document.getElementById('restartGame');
        if (restartGameBtn) {
          restartGameBtn.addEventListener('click', () => {
            document.getElementById('gameOverlay').style.display = 'none';
            game.resetGame();
          });
        }
        
        // å§“åè¼¸å…¥æ¡†å›è»Šæäº¤
        const playerNameInput = document.getElementById('playerName');
        if (playerNameInput) {
          playerNameInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
              document.getElementById('submitScore').click();
            }
          });
        }
        
        console.log('æ‰€æœ‰äº‹ä»¶ç›£è½å™¨è¨­ç½®å®Œæˆ');
        
      } catch (error) {
        console.error('éŠæˆ²åˆå§‹åŒ–å¤±æ•—:', error);
        alert('éŠæˆ²åˆå§‹åŒ–å¤±æ•—: ' + error.message);
      }
    });
  </script>
</body>
</html>