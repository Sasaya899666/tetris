<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>俄羅斯方塊 - 獨立版</title>
  <style>
    /* 全局樣式 */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
      overflow-x: hidden;
    }

    /* 遊戲容器 */
    .game-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    /* 遊戲標題 */
    .game-header {
      text-align: center;
      margin-bottom: 30px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .game-header h1 {
      color: white;
      font-size: 2.5rem;
      margin-bottom: 15px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    /* 主遊戲區域 */
    .main-game-area {
      display: flex;
      gap: 30px;
      justify-content: center;
      align-items: flex-start;
      flex-wrap: wrap;
    }

    /* 遊戲畫布 */
    .game-board {
      position: relative;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    #tetris {
      border: 3px solid #4a90e2;
      border-radius: 10px;
      background: #000;
      box-shadow: inset 0 0 20px rgba(74, 144, 226, 0.3);
    }

    /* 遊戲覆蓋層 */
    .game-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      border-radius: 10px;
    }

    .overlay-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      width: 90%;
    }

    .overlay-content h2 {
      color: #e74c3c;
      margin-bottom: 15px;
      font-size: 1.8rem;
    }

    .overlay-content p {
      font-size: 1.2rem;
      margin-bottom: 20px;
      color: #333;
    }

    /* 遊戲資訊面板 */
    .game-info {
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: 300px;
    }

    .info-section {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .info-section h3 {
      color: white;
      margin-bottom: 15px;
      font-size: 1.2rem;
      text-align: center;
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    .info-item:last-child {
      border-bottom: none;
    }

    .label {
      color: #ddd;
      font-weight: 500;
    }

    .value {
      color: #4a90e2;
      font-weight: bold;
      font-size: 1.1rem;
    }

    #preview {
      border: 2px solid #4a90e2;
      border-radius: 8px;
      background: #000;
      display: block;
      margin: 0 auto;
    }

    /* 按鈕樣式 */
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
      text-align: center;
      min-width: 100px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .btn-primary {
      background: linear-gradient(45deg, #4a90e2, #357abd);
      color: white;
    }

    .btn-primary:hover {
      background: linear-gradient(45deg, #357abd, #4a90e2);
    }

    .btn-success {
      background: linear-gradient(45deg, #27ae60, #2ecc71);
      color: white;
    }

    .btn-success:hover {
      background: linear-gradient(45deg, #2ecc71, #27ae60);
    }

    .btn-warning {
      background: linear-gradient(45deg, #f39c12, #e67e22);
      color: white;
    }

    .btn-warning:hover {
      background: linear-gradient(45deg, #e67e22, #f39c12);
    }

    .btn-danger {
      background: linear-gradient(45deg, #e74c3c, #c0392b);
      color: white;
    }

    .btn-danger:hover {
      background: linear-gradient(45deg, #c0392b, #e74c3c);
    }

    .control-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .controls-info {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-item {
      color: #ddd;
      font-size: 14px;
      padding: 5px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .control-item:last-child {
      border-bottom: none;
    }

    /* 本地排行榜 */
    .local-leaderboard {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      margin-top: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .leaderboard-title {
      color: white;
      text-align: center;
      margin-bottom: 15px;
      font-size: 1.2rem;
    }

    .leaderboard-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      margin-bottom: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: white;
    }

    .leaderboard-item:first-child {
      background: linear-gradient(45deg, #ffd700, #ffed4e);
      color: #333;
    }

    .leaderboard-item:nth-child(2) {
      background: linear-gradient(45deg, #c0c0c0, #e0e0e0);
      color: #333;
    }

    .leaderboard-item:nth-child(3) {
      background: linear-gradient(45deg, #cd7f32, #daa520);
      color: white;
    }

    /* 響應式設計 */
    @media (max-width: 768px) {
      .main-game-area {
        flex-direction: column;
        align-items: center;
      }
      
      .game-info {
        width: 100%;
        max-width: 400px;
      }
      
      .game-header h1 {
        font-size: 2rem;
      }
    }

    @media (max-width: 480px) {
      .game-container {
        padding: 10px;
      }
      
      .game-header h1 {
        font-size: 1.5rem;
      }
      
      .info-section {
        padding: 15px;
      }
      
      .btn {
        padding: 10px 20px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <!-- 主標題 -->
    <header class="game-header">
      <h1>🎮 俄羅斯方塊 - 獨立版</h1>
      <p style="color: white; margin: 0;">無需網路連接，離線遊戲</p>
    </header>

    <!-- 主遊戲區域 -->
    <div class="main-game-area">
      <!-- 遊戲畫布 -->
      <div class="game-board">
        <canvas id="tetris" width="300" height="600"></canvas>
        <div class="game-overlay" id="gameOverlay">
          <div class="overlay-content">
            <h2 id="overlayTitle">遊戲結束</h2>
            <p id="overlayMessage">您的分數: <span id="finalScore">0</span></p>
            <div id="nameInputSection" style="display: none;">
              <input type="text" id="playerName" placeholder="請輸入您的姓名 (2-20字元)" maxlength="20" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; margin-bottom: 15px;">
              <button id="submitScore" class="btn btn-primary">提交分數</button>
            </div>
            <button id="restartGame" class="btn btn-primary">重新開始</button>
          </div>
        </div>
      </div>

      <!-- 遊戲資訊面板 -->
      <div class="game-info">
        <div class="info-section">
          <h3>🎯 遊戲資訊</h3>
          <div class="info-item">
            <span class="label">分數:</span>
            <span id="score" class="value">0</span>
          </div>
          <div class="info-item">
            <span class="label">等級:</span>
            <span id="level" class="value">1</span>
          </div>
          <div class="info-item">
            <span class="label">消除行數:</span>
            <span id="lines" class="value">0</span>
          </div>
          <div class="info-item">
            <span class="label">最高分:</span>
            <span id="highscore" class="value">0</span>
          </div>
        </div>

        <div class="info-section">
          <h3>🔮 下一個方塊</h3>
          <canvas id="preview" width="120" height="120"></canvas>
        </div>

        <div class="info-section">
          <h3>🎮 遊戲控制</h3>
          <div class="control-buttons">
            <button id="startBtn" class="btn btn-success">開始遊戲</button>
            <button id="pauseBtn" class="btn btn-warning">暫停</button>
            <button id="resetBtn" class="btn btn-danger">重新開始</button>
          </div>
        </div>

        <div class="info-section">
          <h3>⌨️ 操作說明</h3>
          <div class="controls-info">
            <div class="control-item">← → 移動</div>
            <div class="control-item">↑ 旋轉</div>
            <div class="control-item">↓ 快速下落</div>
            <div class="control-item">空白鍵 立即落下</div>
            <div class="control-item">P 暫停</div>
          </div>
        </div>
      </div>
    </div>

    <!-- 本地排行榜 -->
    <div class="local-leaderboard">
      <h3 class="leaderboard-title">🏆 本地排行榜</h3>
      <div id="localLeaderboard">
        <!-- 排行榜內容將由JavaScript動態生成 -->
      </div>
    </div>
  </div>

  <script>
    // 俄羅斯方塊遊戲核心邏輯
    class TetrisGame {
      constructor() {
        console.log('開始初始化遊戲...');
        
        this.canvas = document.getElementById('tetris');
        if (!this.canvas) {
          throw new Error('找不到遊戲畫布元素');
        }
        this.context = this.canvas.getContext('2d');
        
        this.previewCanvas = document.getElementById('preview');
        if (!this.previewCanvas) {
          throw new Error('找不到預覽畫布元素');
        }
        this.previewCtx = this.previewCanvas.getContext('2d');
        
        console.log('畫布元素找到，設置縮放...');
        
        // 設置畫布縮放
        this.context.scale(15, 15);
        this.previewCtx.scale(20, 20);
        
        // 遊戲狀態
        this.arena = this.createMatrix(20, 10);
        this.player = {
          pos: {x: 0, y: 0},
          matrix: null,
          next: null
        };
        
        // 遊戲變數
        this.dropCounter = 0;
        this.dropInterval = 1000;
        this.lastTime = 0;
        this.gameOver = false;
        this.paused = false;
        this.score = 0;
        this.level = 1;
        this.lines = 0;
        this.highscore = localStorage.getItem('tetrisHighscore') || 0;
        this.gameStartTime = 0;
        this.gameDuration = 0;
        
        // 方塊顏色
        this.colors = [
          null,
          '#ff0d72', '#0dc2ff', '#0dff72', '#f538ff', '#ff8e0d', '#ffe138', '#3877ff'
        ];
        
        // 方塊類型
        this.pieces = 'TJLOSZI';
        
        // 本地排行榜
        this.localLeaderboard = JSON.parse(localStorage.getItem('tetrisLeaderboard') || '[]');
        
        // 初始化遊戲
        this.init();
      }
      
      init() {
        console.log('初始化遊戲狀態...');
        this.updateScore();
        this.playerReset();
        this.drawPreview();
        this.updateLocalLeaderboard();
        console.log('遊戲初始化完成');
      }
      
      createMatrix(w, h) {
        const matrix = [];
        while (h--) {
          matrix.push(new Array(w).fill(0));
        }
        return matrix;
      }
      
      createPiece(type) {
        const pieces = {
          'T': [[0,1,0],[1,1,1],[0,0,0]],
          'O': [[2,2],[2,2]],
          'L': [[0,0,3],[3,3,3],[0,0,0]],
          'J': [[4,0,0],[4,4,4],[0,0,0]],
          'I': [[0,0,0,0],[5,5,5,5],[0,0,0,0],[0,0,0,0]],
          'S': [[0,6,6],[6,6,0],[0,0,0]],
          'Z': [[7,7,0],[0,7,7],[0,0,0]]
        };
        return pieces[type];
      }
      
      drawMatrix(matrix, offset, ctx) {
        matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              ctx.fillStyle = this.colors[value];
              ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
              
              // 添加邊框效果
              ctx.strokeStyle = '#000';
              ctx.lineWidth = 0.05;
              ctx.strokeRect(x + offset.x, y + offset.y, 1, 1);
            }
          });
        });
      }
      
      draw() {
        try {
          this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
          
          // 繪製網格背景
          this.drawGrid();
          
          // 繪製遊戲區域
          this.drawMatrix(this.arena, {x: 0, y: 0}, this.context);
          this.drawMatrix(this.player.matrix, this.player.pos, this.context);
        } catch (error) {
          console.error('繪製遊戲時發生錯誤:', error);
        }
      }
      
      drawGrid() {
        this.context.strokeStyle = '#333';
        this.context.lineWidth = 0.1;
        
        // 繪製垂直線
        for (let x = 0; x <= 10; x++) {
          this.context.beginPath();
          this.context.moveTo(x, 0);
          this.context.lineTo(x, 20);
          this.context.stroke();
        }
        
        // 繪製水平線
        for (let y = 0; y <= 20; y++) {
          this.context.beginPath();
          this.context.moveTo(0, y);
          this.context.lineTo(10, y);
          this.context.stroke();
        }
      }
      
      drawPreview() {
        this.previewCtx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
        if (this.player.next) {
          this.drawMatrix(this.player.next, {x: 1, y: 1}, this.previewCtx);
        }
      }
      
      merge(arena, player) {
        player.matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              arena[y + player.pos.y][x + player.pos.x] = value;
            }
          });
        });
      }
      
      collide(arena, player) {
        const m = player.matrix;
        const o = player.pos;
        for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 && 
                (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
              return true;
            }
          }
        }
        return false;
      }
      
      playerDrop() {
        this.player.pos.y++;
        if (this.collide(this.arena, this.player)) {
          this.player.pos.y--;
          this.merge(this.arena, this.player);
          this.playerReset();
          this.arenaSweep();
          this.updateScore();
        }
        this.dropCounter = 0;
      }
      
      playerMove(dir) {
        this.player.pos.x += dir;
        if (this.collide(this.arena, this.player)) {
          this.player.pos.x -= dir;
        }
      }
      
      playerReset() {
        console.log('重置玩家狀態...');
        this.player.matrix = this.player.next || this.createPiece(this.pieces[Math.floor(Math.random() * this.pieces.length)]);
        this.player.next = this.createPiece(this.pieces[Math.floor(Math.random() * this.pieces.length)]);
        this.player.pos.y = 0;
        this.player.pos.x = (this.arena[0].length / 2 | 0) - (this.player.matrix[0].length / 2 | 0);
        
        console.log('玩家位置:', this.player.pos);
        console.log('玩家方塊:', this.player.matrix);
        
        if (this.collide(this.arena, this.player)) {
          console.log('遊戲結束！');
          this.gameOver = true;
          this.endGame();
        }
        this.drawPreview();
      }
      
      playerRotate() {
        const m = this.player.matrix;
        for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < y; ++x) {
            [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
          }
        }
        m.forEach(row => row.reverse());
        
        if (this.collide(this.arena, this.player)) {
          m.forEach(row => row.reverse());
          for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < y; ++x) {
              [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
            }
          }
        }
      }
      
      arenaSweep() {
        let rowCount = 1;
        let linesCleared = 0;
        
        outer: for (let y = this.arena.length - 1; y >= 0; --y) {
          for (let x = 0; x < this.arena[y].length; ++x) {
            if (this.arena[y][x] === 0) continue outer;
          }
          
          const row = this.arena.splice(y, 1)[0].fill(0);
          this.arena.unshift(row);
          ++y;
          linesCleared++;
          
          // 分數計算：基礎分數 * 等級 * 連鎖倍數
          this.score += rowCount * 100 * this.level;
          rowCount *= 2;
        }
        
        this.lines += linesCleared;
        
        // 等級提升
        if (this.lines >= this.level * 10) {
          this.level++;
          this.dropInterval = Math.max(100, 1000 - (this.level - 1) * 100);
        }
      }
      
      update(time = 0) {
        if (this.paused || this.gameOver) {
          console.log('遊戲暫停或結束，停止更新');
          return;
        }
        
        const deltaTime = time - this.lastTime;
        this.lastTime = time;
        
        this.dropCounter += deltaTime;
        if (this.dropCounter > this.dropInterval) {
          this.playerDrop();
        }
        
        this.draw();
        requestAnimationFrame((time) => this.update(time));
      }
      
      updateScore() {
        document.getElementById('score').innerText = this.score.toLocaleString();
        document.getElementById('level').innerText = this.level;
        document.getElementById('lines').innerText = this.lines;
        
        if (this.score > this.highscore) {
          this.highscore = this.score;
          localStorage.setItem('tetrisHighscore', this.highscore);
          document.getElementById('highscore').innerText = this.highscore.toLocaleString();
        }
      }
      
      startGame() {
        console.log('開始遊戲...');
        if (this.gameOver) {
          console.log('遊戲結束狀態，重置遊戲');
          this.resetGame();
        }
        this.paused = false;
        this.gameStartTime = Date.now();
        this.lastTime = 0; // 重置時間
        console.log('開始遊戲循環');
        this.update();
      }
      
      pauseGame() {
        this.paused = !this.paused;
        if (!this.paused) {
          this.update();
        }
      }
      
      resetGame() {
        this.arena = this.createMatrix(20, 10);
        this.score = 0;
        this.level = 1;
        this.lines = 0;
        this.dropInterval = 1000;
        this.gameOver = false;
        this.paused = false;
        this.gameStartTime = 0;
        this.gameDuration = 0;
        
        this.playerReset();
        this.updateScore();
        this.update();
      }
      
      endGame() {
        this.gameDuration = Math.floor((Date.now() - this.gameStartTime) / 1000);
        
        // 檢查是否為前10名
        this.checkLocalLeaderboard();
        
        // 顯示遊戲結束畫面
        this.showGameOver();
      }
      
      showGameOver() {
        const overlay = document.getElementById('gameOverlay');
        const title = document.getElementById('overlayTitle');
        const message = document.getElementById('overlayMessage');
        const finalScore = document.getElementById('finalScore');
        const nameInputSection = document.getElementById('nameInputSection');
        
        title.innerText = '遊戲結束！';
        finalScore.innerText = this.score.toLocaleString();
        
        // 檢查是否需要輸入姓名
        if (this.score > 0) {
          nameInputSection.style.display = 'block';
          message.innerText = `您的分數: ${this.score.toLocaleString()}`;
        } else {
          nameInputSection.style.display = 'none';
          message.innerText = '遊戲結束！';
        }
        
        overlay.style.display = 'flex';
      }
      
      checkLocalLeaderboard() {
        // 檢查是否為前10名
        const isTop10 = this.localLeaderboard.length < 10 || this.score > this.localLeaderboard[this.localLeaderboard.length - 1].score;
        
        if (isTop10) {
          // 顯示姓名輸入
          document.getElementById('nameInputSection').style.display = 'block';
        }
      }
      
      submitLocalScore(playerName) {
        // 添加到本地排行榜
        this.localLeaderboard.push({
          name: playerName,
          score: this.score,
          level: this.level,
          lines_cleared: this.lines,
          date: new Date().toLocaleDateString()
        });
        
        // 排序並只保留前10名
        this.localLeaderboard.sort((a, b) => b.score - a.score);
        this.localLeaderboard = this.localLeaderboard.slice(0, 10);
        
        // 保存到本地存儲
        localStorage.setItem('tetrisLeaderboard', JSON.stringify(this.localLeaderboard));
        
        // 更新顯示
        this.updateLocalLeaderboard();
        
        alert(`恭喜！您的分數已記錄到本地排行榜！`);
      }
      
      updateLocalLeaderboard() {
        const leaderboardDiv = document.getElementById('localLeaderboard');
        leaderboardDiv.innerHTML = '';
        
        if (this.localLeaderboard.length === 0) {
          leaderboardDiv.innerHTML = '<div style="color: white; text-align: center;">暫無記錄</div>';
          return;
        }
        
        this.localLeaderboard.forEach((player, index) => {
          const item = document.createElement('div');
          item.className = 'leaderboard-item';
          item.innerHTML = `
            <div>
              <strong>${index + 1}. ${player.name}</strong>
              <div style="font-size: 0.9em; opacity: 0.8;">等級: ${player.level} | 行數: ${player.lines_cleared}</div>
            </div>
            <div style="text-align: right;">
              <div style="font-weight: bold;">${player.score.toLocaleString()}</div>
              <div style="font-size: 0.8em; opacity: 0.8;">${player.date}</div>
            </div>
          `;
          leaderboardDiv.appendChild(item);
        });
      }
      
      // 鍵盤控制
      handleKeydown(event) {
        if (this.gameOver) return;
        
        switch(event.key) {
          case 'ArrowLeft':
            this.playerMove(-1);
            break;
          case 'ArrowRight':
            this.playerMove(1);
            break;
          case 'ArrowDown':
            this.playerDrop();
            break;
          case 'ArrowUp':
            this.playerRotate();
            break;
          case ' ':
            // 硬降
            while (!this.collide(this.arena, this.player)) {
              this.player.pos.y++;
            }
            this.player.pos.y--;
            this.merge(this.arena, this.player);
            this.playerReset();
            this.arenaSweep();
            this.updateScore();
            break;
          case 'p':
          case 'P':
            this.pauseGame();
            break;
        }
      }
    }

    // 初始化遊戲
    let game;

    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM載入完成，初始化遊戲...');
      
      try {
        game = new TetrisGame();
        console.log('遊戲初始化成功');
        
        // 導出遊戲實例供其他模組使用
        window.game = game;
        
        // 鍵盤事件監聽
        document.addEventListener('keydown', (event) => {
          game.handleKeydown(event);
        });
        
        // 按鈕事件
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        if (startBtn) {
          startBtn.addEventListener('click', () => {
            console.log('開始遊戲按鈕被點擊');
            game.startGame();
          });
        } else {
          console.error('找不到開始遊戲按鈕');
        }
        
        if (pauseBtn) {
          pauseBtn.addEventListener('click', () => {
            console.log('暫停按鈕被點擊');
            game.pauseGame();
          });
        } else {
          console.error('找不到暫停按鈕');
        }
        
        if (resetBtn) {
          resetBtn.addEventListener('click', () => {
            console.log('重新開始按鈕被點擊');
            game.resetGame();
          });
        } else {
          console.error('找不到重新開始按鈕');
        }
        
        // 提交分數
        const submitScoreBtn = document.getElementById('submitScore');
        if (submitScoreBtn) {
          submitScoreBtn.addEventListener('click', () => {
            const playerName = document.getElementById('playerName').value.trim();
            if (playerName.length >= 2 && playerName.length <= 20) {
              game.submitLocalScore(playerName);
              document.getElementById('gameOverlay').style.display = 'none';
            } else {
              alert('請輸入2-20字元的姓名');
            }
          });
        }
        
        // 重新開始遊戲
        const restartGameBtn = document.getElementById('restartGame');
        if (restartGameBtn) {
          restartGameBtn.addEventListener('click', () => {
            document.getElementById('gameOverlay').style.display = 'none';
            game.resetGame();
          });
        }
        
        // 姓名輸入框回車提交
        const playerNameInput = document.getElementById('playerName');
        if (playerNameInput) {
          playerNameInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
              document.getElementById('submitScore').click();
            }
          });
        }
        
        console.log('所有事件監聽器設置完成');
        
      } catch (error) {
        console.error('遊戲初始化失敗:', error);
        alert('遊戲初始化失敗: ' + error.message);
      }
    });
  </script>
</body>
</html>